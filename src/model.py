from pubsub import Publisher
import random
import util

from log import Log
log = Log()
#log.setVerbosity(Log.VERBOSITY_VERBOSE)

class ServerModel:
    def __init__(self):
        self.messages = []
        self.messageBoxes = {}

    def connectMessageBox(self, addr):
        self.messageBoxes[addr] = []
        for m in self.messages:
            self.messageBoxes[addr].append(m)

    def receiveMessage(self, m):
        self.messages.append(m)
        for addr in self.messageBoxes:
            self.messageBoxes[addr].append(m)

    def getAllMessages(self, addr):
        buf = b""
        for m in self.messageBoxes[addr]:
            buf += m
        return buf

    def clearMessages(self, addr):
        self.messageBoxes[addr] = []


# the events generated by a Model instance 
clientModelEvents = ["msg_received", "msg_sent"]

class ClientModel(Publisher):
    def __init__(self):
        self.received = []
        self.sent = []
        Publisher.__init__(self, clientModelEvents)

    def receiveMessage(self, m):
        self.received.append(m)
        Publisher.dispatch(self, "msg_received", (self.received, m))
 
    def addSentMessage(self, m):
        self.sent.append(m)
        Publisher.dispatch(self, "msg_sent", (self.sent, m))

class GameConstants:
    BLACK = 0
    BLUE = 1
    RED = 2
    ORANGE = 3
    NOCOLOR = 99
    TILECOLORS = [BLACK,BLUE,RED,ORANGE]
    TILECOLORNAMES = ["black", "blue", "red", "orange"]
    MAXTILEVALUE = 13
    TILEVALUES = range(1,MAXTILEVALUE+1)
    MODELEVENTS = ["msg_modified"]

class ModelObject(Publisher):
    def __init__(self, parent=None):
        super().__init__(GameConstants.MODELEVENTS)
        self.__modified__ = False
        self.__children__ = []
        self.__parent__ = None
        if parent:
            assert isinstance(parent, ModelObject)
            self.__parent__ = parent
            parent.addChild(self)

    def setModified(self):
        self.__modified__ = True
        Publisher.dispatch(self, "msg_modified", self)

    def clearModified(self, recursive=False):
        self.__modified__ = False
        if recursive:
            for c in self.getChildren():
                c.clearModified(recursive)
        log.trace(type(self), ".clearModified(", recursive, ") --> ", self.__modified__)

    def getParent(self):
        return self.__parent__

    def getChildren(self):
        return self.__children__

    def addChild(self, childObject):
        assert isinstance(childObject, ModelObject)
        self.__children__.append(childObject)

    def isModified(self, recursive=False):
        if not self.__modified__ and recursive:
            return self.isChildModified(recursive)
        else:
            return self.__modified__

    def isChildModified(self, recursive=False):
        for c in self.getChildren():
            if recursive:
                return c.isModified(recursive)

    def getModifiedObjects(self):
        modified = []
        if self.__modified__:
            modified.append(self)
        for c in self.getChildren():
            modified = modified + c.getModifiedObjects()
        return modified



class TileContainer(ModelObject):
    def __init__(self, parent):
        super().__init__(parent)
        self.__tiles__ = {}
        self.lastTilePosition = 0

    def getTiles(self):
        return self.__tiles__

    def copyTiles(self):
        return self.__tiles__.copy()

    def getSize(self):
        return len(self.__tiles__)

    def getTile(self, tileId):
        return self.__tiles__[tileId]

    def setTile(self, tileId, tile):
        self.__tiles__[tileId] = tile
        self.setModified()

    def containsTile(self, tileId):
        return tileId in self.__tiles__

    def getTilesSortedByValue(self):
        return sorted(self.copyTiles().values(), key= lambda tile: tile.value)

    def addTile(self, tile):
        fitPos = self.tileFitPosition(tile)
        log.trace(str(type(self)), ".addTile(", tile.toString(), ") --> ", fitPos)
        if fitPos>0:
            self.setTile(tile.id(), tile)
            self.lastTilePosition = fitPos
            tile.container = self
        return fitPos

    def moveTile(self, tile, targetContainer):
        #log.trace("moveTile(", tile.toString(), targetContainer.toString(), ")")
        #log.trace("before move:", self.toString())
        tId = tile.id()
        if self.containsTile(tId):
            if targetContainer.addTile(tile)>0:
                self.__tiles__.pop(tId)
            return True
        else:
            return False

    def findTile(self, value, color):
        for t in self.getTiles().values():
            if (t.value==value and t.color==color):
                return t

    def tileFitPosition(self, tile):
        return 1

    def isEmpty(self):
        return (self.getSize()==0)

    def toString(self):
        groupedByColor = sorted(self.getTiles().values(), key= lambda tile: tile.color)
        s = str(type(self)) + "(" + str(len(groupedByColor)) + " tiles):"
        currentColor = None
        for tile in groupedByColor:
            if tile.color != currentColor:
                currentColor = tile.color
                s = s + "\n" + GameConstants.TILECOLORNAMES[currentColor] + ": "
            s = s + str(tile.getValue()) + " "
        return s

    def print(self):
        log.trace(self.toString())


class Set(TileContainer):
    SETTYPE_UNDECIDED = 0   
    SETTYPE_GROUP = 1       #consists of tiles with different colors, but identical value
    SETTYPE_RUN = 2         #consists of tiles with different subsequent values of a single color
    SETTYPE_INVALID = -1
    SETTYPES = {
        SETTYPE_UNDECIDED: "Undecided",
        SETTYPE_GROUP: "Group",
        SETTYPE_RUN: "Run",
        SETTYPE_INVALID: "Invalid"
    }
    def __init__(self, parent):
        TileContainer.__init__(self, parent)
        self.order = []
        self.type = None

    def addTile(self, tile):
        fitPos = TileContainer.addTile(self, tile)
        if fitPos>0:
            if fitPos>len(self.order):
                self.order.append(tile.id())
            else:
                self.order.insert(fitPos-1, tile.id())
        return fitPos

    def moveTile(self, tile, targetContainer):
        if TileContainer.moveTile(self, tile, targetContainer):
#            tile.forgetPlate()
            for i in range(len(self.order)-1):
                if self.order[i] == tile.id():
                    self.order.pop(i)
            return True
        else:
            return False

    def isValidRun(self, tiles):
        """
        checks whether tiles is a valid run, by determining the largest and smallest difference between the tiles
        for a valid run, both the largest difference and smallest difference is exactly 1 
        """
        N = len(tiles)
        largestDiff = 0
        smallestDiff = GameConstants.MAXTILEVALUE
        for i in range(N):
            if i>0:
                prevValue = tiles[i-1].getValue(context = tiles, settype = Set.SETTYPE_RUN)
                thisValue = tiles[i].getValue(context = tiles, settype = Set.SETTYPE_RUN)
                diff = thisValue - prevValue
                if diff>largestDiff:
                    largestDiff = diff
                if diff<smallestDiff:
                    smallestDiff = diff
        log.trace(type(self), ".isValidRun(", util.collectionToString(tiles, lambda item: str(item.getValue(context=tiles, settype = Set.SETTYPE_RUN))), ") --> ", (largestDiff,smallestDiff))
        return (largestDiff==1 and smallestDiff==1)

    def isValidGroup(self, tiles):
        N = len(tiles)
        return N>2 and N<5

    def getSetType(self, tiles):
        """
        parameters:
        - tiles: a flat list of Tile instances (not a Dict)
        To do so it first tries to determine the type of the set, based on the current contents.
        A GROUP contains tiles of the same value, with different colors
        A RUN contains a number range (for example, 2,3,4) with the same color    
        """
        settype = Set.SETTYPE_INVALID
        distinctcolors = {} 
        distinctvalues = {} 
        for t in tiles:
            #get the value of the tile 
            #if t is an instance of Joker, than that value depends of its neighbours
            v = t.getValue(context = tiles)
            if isinstance(t,Joker):
                # a joker is registered as a separate color
                c = GameConstants.NOCOLOR
            else:
                c = t.getColor(context = tiles)
            if c in distinctcolors: distinctcolors[c]+=1 
            else: distinctcolors[c]=1
            if v in distinctvalues: distinctvalues[v]+=1 
            else: distinctvalues[v]=1
        doublecolors = util.filteredCount(lambda x: x>1, distinctcolors.values())
        doublevalues = util.filteredCount(lambda x: x>1, distinctvalues.values())
        DV = len(distinctvalues) #number of distinct values
        DC = len(distinctcolors) #number of distinct colors
        containsjoker = GameConstants.NOCOLOR in distinctcolors
        if DC==1 and DV==1:
            #the set contains a single tile, so the type cannot be determined yet
            settype = Set.SETTYPE_UNDECIDED
        elif DC>=1 and DV==1:
            #the set contains multiple tiles of a single color
            if containsjoker and DV==1:
                #the set contains a joker, and one other tile
                #because of the joker, the set type cannot be determined at this point
                settype = Set.SETTYPE_UNDECIDED
            else:
                #the set contains multiple tiles (possibly with a joker) with the same value, in multiple colors
                if doublecolors==0:
                    settype = Set.SETTYPE_GROUP
        elif DV>=1 and (DC==1 or (DC==2 and containsjoker)):
            #the set contains multiple distinct values of a single color and perhaps a joker (DC==2)
            if doublevalues==0 and self.isValidRun(tiles):
                settype = Set.SETTYPE_RUN
        log.trace(
            type(self), 
            ".getSetType(", 
            util.collectionToString(
                tiles, 
                lambda item: str(item.getValue(context=tiles, settype=settype))), 
            ") --> ", 
            Set.SETTYPES[settype]
        )
        return settype

    def tileFitPosition(self, tile):
        if self.containsTile(tile.id()): return 0
        sortedTiles = self.getTilesSortedByValue()
        N = len(sortedTiles)
        #try adding the new tile at the end of the set
        if self.getSetType(sortedTiles+[tile]) != Set.SETTYPE_INVALID:
            return N+1
        #try adding the new tile at the beginning of the set
        elif self.getSetType([tile]+sortedTiles) != Set.SETTYPE_INVALID:
            return 1
        else:
            return 0

    def isValid(self):
        return self.getSize()>=3 and self.getSetType(self.getTilesSortedByValue()) != Set.SETTYPE_INVALID


class Tile(ModelObject):
    def __init__(self, id, color, value, container):
        super().__init__(None) # Tile instances have no parent for now
        self.__id__ = id
        self.value = value
        self.color = color
        self.container = container
        self.plate = None

    def id(self):
        return self.__id__

    def move(self, targetContainer):
        if self.container.moveTile(self, targetContainer):
            self.setModified()
            return True
        return False
        

    def rememberPlate(self, plate):
        if isinstance(plate, Plate):
            self.plate = plate
    
    def forgetPlate(self):
        self.plate = None

    def toString(self):
        s = "Tile" + str(self.__id__) + "("
        s = s + str(self.value) + ","
        s = s + GameConstants.TILECOLORNAMES[self.color]
        s = s + ")"
        return s

    def getValue(self, *args, **kwargs):
        return self.value

    def getColor(self, *args, **kwargs):
        return self.color

    def print(self):
        log.trace(self.toString())

class Joker(Tile):
    def __init__(self, id, color, container):
        Tile.__init__(self, id, color, 0, container)

    def getNeighbours(self, *args, **kwargs):
        try:
            context = kwargs["context"]
        except KeyError as e:
            if isinstance(self.container, Set): 
                context = self.container.getTiles()
        left,right = (None,None)
        if self in context:
            i = context.index(self)
            if i>0:
                left = context[i-1]
            if i<len(context)-1:
                right = context[i+1]
        log.trace(type(self), ".getNeighbours(", util.collectionToString(context, lambda item: str(item.value)), ") --> ", (left,right))
        return (left,right)

    def getColor(self, *args, **kwargs):
        try:
            settype = kwargs["settype"]
        except KeyError as e:
            settype = None
        left,right = self.getNeighbours(*args, **kwargs)
        if left and right:
            if (left.getValue() == right.getValue()):
                return self.color
            if (left.getValue()-2 == right.getValue()):
                return left.getColor()
        elif left:
            if settype == Set.SETTYPE_RUN:
                return left.getColor()
            elif settype == Set.SETTYPE_GROUP:
                return GameConstants.NOCOLOR
        elif right:
            if settype == Set.SETTYPE_RUN:
                return right.getColor()
            elif settype == Set.SETTYPE_GROUP:
                return GameConstants.NOCOLOR
        return self.color

    def getValue(self, *args, **kwargs):
        try:
            settype = kwargs["settype"]
        except KeyError as e:
            settype = None
        left,right = self.getNeighbours(*args, **kwargs)
        if left and right:
            if (left.getValue() == right.getValue()):
                return left.getValue()
            if (left.getValue()-2 == right.getValue()):
                return left.getValue()+1
        elif left:
            if settype == Set.SETTYPE_RUN:
                return left.getValue()+1
            elif settype == Set.SETTYPE_GROUP:
                return left.getValue()
        elif right:
            if settype == Set.SETTYPE_RUN:
                return right.getValue()-1
            elif settype == Set.SETTYPE_GROUP:
                return right.getValue()
        return self.value

    def toString(self):
        s = "Joker(" + GameConstants.TILECOLORNAMES[self.color] + ")"
        return s

class Pile(TileContainer):
    def __init__(self, parent):
        self.nextId = 0
        TileContainer.__init__(self, parent)
        for color in GameConstants.TILECOLORS:
            for value in GameConstants.TILEVALUES:
                for i in range(2):
                    t = Tile(self.getNextId(), color, value, self)
                    TileContainer.addTile(self, t)
        TileContainer.addTile(self, Joker(self.getNextId(), GameConstants.BLACK, self))
        TileContainer.addTile(self, Joker(self.getNextId(), GameConstants.RED, self))

    def getNextId(self):
        nextId = self.nextId
        self.nextId = self.nextId+1
        return nextId

    def pickTile(self, player):
        tiles = self.getTiles().items()
        n = len(tiles)
        pickedTile = None
        if n>0:
            pickedTile = self.getTile(random.sample(list(self.getTiles()), 1)[0])
            log.trace("picked: ", pickedTile.toString())
            pickedTile.move(player.plate)
        return pickedTile



class Board(TileContainer):
    def __init__(self, parent):
        TileContainer.__init__(self, parent)
        self.sets = []

    def createSet(self, tile):
        set = Set(self)
        tile.move(set)
        return set

    def cleanUp(self, validateSets=True):
        #cleanup unfinished and invalid sets
        for s in self.sets:
            if not s.isEmpty():
                if validateSets and s.isValid():
                    # make the valid moves permanent
                    for tId in s.copyTiles():
                        t = s.getTile(tId)
                        t.forgetPlate()
                else:
                    # undo the invalid moves (move back to the player's plate)
                    for tId in s.copyTiles():
                        t = s.getTile(tId)
                        if t.plate:
                            #move tile back to the current player's plate
                            t.move(t.plate)
        #remove all empty sets
        i = 0
        for s in self.sets:
            if s.isEmpty():
                self.sets.pop(i)
            else:
                i+=1

    def addTile(self, tile):
        TileContainer.addTile(self, tile)
        set = self.createSet(tile)
        self.sets.append(set)
        self.setModified()
        return 1

    def toString(self):
        s = "Board(" + str(len(self.sets)) + " sets):"
        for set in self.sets:
            s = s + "\n" + set.toString()
        return s

class Plate(TileContainer):
    def __init__(self, player):
        self.player = player
        TileContainer.__init__(self, self.player)

    def moveTile(self, tile, targetContainer):
        if TileContainer.moveTile(self, tile, targetContainer):
            tile.rememberPlate(self)
            return True
        else:
            return False

class Player(ModelObject):
    def __init__(self, name, game):
        super().__init__(game)
        self.plate = Plate(self)
        self.name = name
        self.game = game
        for i in range(15):
            self.pickTile()

    def getPlate(self):
        return self.plate

    def pickTile(self):
        return self.game.pile.pickTile(self)

    def commitMoves(self):
        self.game.commitMoves(self)

    def toString(self):
        s =  "player: " + self.name + self.plate.toString()
        return s

    def print(self):
        log.trace(self.toString())

class Game(ModelObject):
    def __init__(self, maxPlayers=4):
        super().__init__()
        self.players = {}
        self.board = Board(self)
        self.pile = Pile(self)
        self.maxPlayers = maxPlayers

    def addPlayer(self, name):
        if len(self.players) < self.maxPlayers:
            self.players[name] = Player(name, self)
            self.setModified()

    def getPlayer(self, name):
        return self.players[name]

    def commitMoves(self, player):
        assert isinstance(player, Player)
        if player.getParent() == self:
            # clean the board with validation
            self.board.cleanUp(True)
            # recursively clear the modified flag of all ModelObject instances under Game
            self.clearModified(True) 

    def toString(self):
        s = "\ngame(" + str(len(self.players)) + " players):\n"
        for name in self.players:
            s = s + self.players[name].toString()
        s = s + "\npile: " + self.pile.toString()
        s = s + "\nboard: " + self.board.toString()
        return s

    def print(self):
        log.trace(self.toString())


class Model:
    def __init__(self):
        self.currentGame = None

    def newGame(self, n):
        self.currentGame = Game(n)

    def addPlayer(self, name):
        if self.currentGame:
            self.currentGame.addPlayer(name)

    def getCurrentGame(self):
        return self.currentGame

    def isGameModified(self):
        return self.currentGame().isModified(True)

    def getPlayer(self, name):
        if self.currentGame:
            return self.currentGame.getPlayer(name)
        return None

class Test:
    def __init__(self):
        pass

    def runAllTests(self):
        self.runGameTest()
        self.runPlayerTest()

    def runGameTest(self):
        game = Game(4)
        game.log.trace()

        tc = game.board
        for v in range(1,4):
            t = game.pile.findTile(v, GameConstants.BLACK)
            t.log.trace()
            t.move(tc)
            tc = t.container
        game.log.trace()

    def runPlayerTest(self):
        game = Game(2)
        game.addPlayer("Joe")
        game.print()

        joe = game.getPlayer("Joe")
        joe.pickTile()
        joe.print()

        for tId in joe.plate.getTiles():
            t = joe.plate.getTile(tId)
            log.trace("\nmoving to board:", t.toString())
            t.move(game.board)
            game.print()
            log.trace("\nboard.cleanUp:")
            game.board.cleanUp()
            game.print()
            log.trace("\nmoving back to plate:", t.toString())
            t.move(joe.plate)
            game.board.cleanUp()
            game.print()
            break

if __name__ == "__main__":
    test = Test()
    #test.runAllTests()
    test.runPlayerTest()

   